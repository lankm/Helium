# This is a comment. It must have a pound sign at the begining and end #

# An identifier is a location in memory #
# A type defines the size in memory #
# Whitespace is not required #

# TYPES
  int  -15
  whl  42
  flt  12.21
  str "abc"
  chr '+'
  arr [1,2,3]
  rec [a:=1,b:="xyz",c:=15.5]
  enm [a,b,c,d]
  fct f(x: flt): flt = {f=3*x}
#

# PARADIGM
  [ ] STRUCTURED
    [x] Sequence     {a;b;c;}
    [x] Repetition   @ i<9 : {}
    [x] Selection    ? i>2 : {} ! {}
    [x] Subroutine   f(x:T):T = {f = 2*x}
  [ ] OBJECT ORIENTED
    [ ] Encapsulation class
    [ ] Abstraction   abstract
    [ ] Inheritance   extend
    [ ] Polymorphism  
  [ ] FUNCTIONAL
    [ ] Immutability const
    [ ] Pure Functions
    [ ] Higher Order Functions
  [ ] OWNERSHIP
    [ ] own
    [ ] borrow
#

# THEORY
  MATHMATICS
  [ ] NUMBER THEORY
  [ ] GEOMETRY
  [ ] ALGEBRA
    [ ] Boolean
    [ ] Linear
  [ ] DISCRETE
    [ ] Graph
  [ ] SET THEORY
  [ ] LOGIC
  [ ] PROBABILITY & STATISTICS

  SCIENCE
  [ ] Units
  [ ] Tests
  [ ] Logging
#

# Character Mapping
  - !:
  - ": Strings
  - #: Comment
  - $:
  - %: Math
  - &:
  - ': Characters
  - (:
  - ):
  - *: Math Boolean
  - +: Math Boolean
  - ,: Data
  - -: Math Boolean
  - .:
  - /:
  - 0: User-Defined
  ...
  - :: Types
  - ;: Code
  - <: Types Boolean
  - =: Assignment
  - >: Types Boolean
  - ?:
  - @:
  - A: User-Defined
  ...
  - [: Data
  - \: Math
  - ]: Data
  - ^: Math Boolean
  - _: User-Defined
  - `:
  - a: User-Defined
  ...
  - {: Code
  - |:
  - }: Code
  - ~:
#

# CONTEXT FREE GRAMMER
  HELIUM            => SEQUENCE_* STATEMENT
  COMMENT           => # ... #

  INTEGER           =>  ...
  WHOLE             =>  ...
  FLOAT             =>  ...
  STRING            =>  "..."
  CHARACTER         =>  '...'
  ARRAY             =>  [ ARRAY_* VALUE ]
    ARRAY_          =>  VALUE ,
  TUPLE             =>  [ TUPLE_* DECLARATION ]
    TUPLE_          =>  DECLARATION ,
  VALUE             =>  INTEGER | WHOLE | FLOAT | STRING | CHARACTER | ARRAY | TUPLE
  TYPE              =>  int     | whl   | flt   | str    | chr       | arr   | tup

  IDENTIFER         => ...

  DEFINITION        =>  IDENTIFIER : TYPE
  DECLARATION       =>  IDENTIFIER : TYPE? = EXPRESSION
  INITIALIZATION    =>  DEFINITION | DECLARATION
    INITIALIZATION_ =>  INITIALIZATION_ ,
  PARAMTETERS       =>  INITIALIZATION_* INITIALIZATION
  FUNCTION          =>  IDENTIFIER ( PARAMTETERS ) : TYPE? = SEQUENCE

  STATEMENT         =>  INITIALIZATION | REPETITION | SELECTION | SEQUENCE | CALL
  EXPRESSION        =>  VALUE | ...

  REPETITION        =>  @ CONDITIONAL : SEQUENCE
  SELECTION         =>  ? CONDITIONAL : SEQUENCE ! SEQUENCE
  SEQUENCE          =>  { SEQUENCE_* STATEMENT }
    SEQUENCE_       =>  STATEMENT ;
  CALL              =>  IDENTIFIER ( EXPRESSION* )
#

# make a difference between a function that returns a variable and one that doesn't. consider pure functions #
# there will already be a semantic difference. think about a syntactic difference #
{
  # differentiate between static and instance #

  author: rec = [
    name: str = "Landon",
    age: int = 22
  ];

  class: cls = [
    getName(): str,
    setName():,
    calculateAge(): whl
  ]


  i: int = 0;
  @ i<10 : {
    i := i+1;
  };

  ? i>5
    : {i:=10}
    ! {i:=4};

  fib(n:int) := {
    ? n<1
      : { fib := 0 }
      ! { fib := fib(n-1) + n }
  };

  # parameters with default values are allowed in any order #
  # parameters are treated similarly to records #
  greet(name: str, greeing:="Hello") := { 
    echo(greeting +" " + name)
  };

  # function arguments follow a similar format as records #
  # arguments must be supplied for all parameters without default values #
  # all arguments are named #
  greet(name:=author.name)
}

